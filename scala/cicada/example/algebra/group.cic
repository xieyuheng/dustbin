class group_t extends monoid_t {
  fn inv(x: E): eqv_t(mul(id, x), x)
  fn left_inv(x: E): eqv_t(mul(inv(x), x), id)
  fn right_inv(x: E): eqv_t(mul(x, inv(x)), id)

  fn div(x: E, y: E): E = mul(x, inv(y))
}

class group_hom_t {
  let G: group_t
  let H: group_t

  fn hom(G.E): H.E
  fn hom_respect_mul(x: G.E, y: G.E): eqv_t(
    hom(G.mul(x, y)),
    H.mul(hom(x), hom(y)))
}

fn id_group_hom(G: group_t): group_hom_t = group_hom_t(
  G, G,
  (x: G.E): G.E => x,
  (x: G.E, y: G.E): TODO => same(G.mul(x, y)),
)

let group_category: category_t = category_t(
  group_t,
  group_hom_t,
  id_group_hom,

  (f: group_hom_t(G, H), g: group_hom_t(H, K)): TODO => group_hom_t(
    G, K,
    (x: G.E): TODO => { g.hom(f.hom(x)) },
    (x: G.E, y: G.E): TODO => same(g.hom(H.mul(f.hom(x), f.hom(y))))),

  (f: group_hom_t(G, H)): TODO => same(f),
  (f: group_hom_t(G, H)): TODO => same(f),

  (f: group_hom_t(a, b), g: group_hom_t(b, c), h: group_hom_t(c, d)): TODO => refl
)
