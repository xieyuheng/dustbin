;; Compute the Ackermann function recursively.
;; WARNING: Will quickly exceed stack size

(export ackermann)

(define-function ackermann
  (block entry
    (= m (argument 0))
    (= n (argument 1))
    (= zero (literal 0))
    (= one (literal 1))
    (= cond-m (call (@primitive-function equal? 2) m zero))
    (branch cond-m m-zero m-nonzero))

  (block m-zero
    (= tmp (call (@primitive-function iadd 2) n one))
    (return tmp))

  (block m-nonzero
    (= cond-n (call (@primitive-function equal? 2) n zero))
    (branch cond-n n-zero n-nonzero))

  (block n-zero
    (= m1 (call (@primitive-function isub 2) m one))
    (= tmp (call (@function ackermann 2) m1 one))
    (return tmp))

  (block n-nonzero
    (= m1 (call (@primitive-function isub 2) m one))
    (= n1 (call (@primitive-function isub 2) n one))
    (= t1 (call (@function ackermann 2) m n1))
    (= t2 (call (@function ackermann 2) m1 t1))
    (return t2)))
